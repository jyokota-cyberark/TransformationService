# Transformation Service - Enhancement Implementation Plan

## Overview

This document outlines the implementation plan for three key enhancements to the Transformation Service:

1. **DAG Auto-Generation API** - Generate Airflow DAGs from transformation rules
2. **Transformation Projects** - Group related rules into projects/pipelines
3. **Rule Versioning** - Track rule change history

---

## Enhancement 1: DAG Auto-Generation API

### Objective

Enable automatic generation of Airflow DAGs from transformation rule definitions through an API endpoint, eliminating the need for manual DAG creation.

### Design

#### Database Schema

```sql
-- Table: AirflowDagDefinitions
CREATE TABLE "AirflowDagDefinitions" (
    "Id" SERIAL PRIMARY KEY,
    "DagId" VARCHAR(255) NOT NULL UNIQUE,
    "EntityType" VARCHAR(100) NOT NULL,
    "Description" TEXT,
    "Schedule" VARCHAR(100),  -- Cron expression
    "IsActive" BOOLEAN DEFAULT true,
    "TransformationProjectId" INT,  -- Link to project (optional)
    "SparkJobId" INT,  -- Spark job to execute
    "Configuration" JSONB,  -- DAG-specific config
    "GeneratedDagPath" TEXT,  -- Path to generated DAG file
    "LastGeneratedAt" TIMESTAMP,
    "CreatedAt" TIMESTAMP DEFAULT NOW(),
    "UpdatedAt" TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY ("TransformationProjectId") REFERENCES "TransformationProjects"("Id"),
    FOREIGN KEY ("SparkJobId") REFERENCES "SparkJobDefinitions"("Id")
);

CREATE INDEX "IX_AirflowDagDefinitions_EntityType" ON "AirflowDagDefinitions"("EntityType");
CREATE INDEX "IX_AirflowDagDefinitions_IsActive" ON "AirflowDagDefinitions"("IsActive");
```

#### API Endpoints

```
POST   /api/airflow/dags/generate          - Generate new DAG
GET    /api/airflow/dags                   - List all DAG definitions
GET    /api/airflow/dags/{dagId}           - Get DAG definition
PUT    /api/airflow/dags/{dagId}           - Update DAG definition
DELETE /api/airflow/dags/{dagId}           - Delete DAG definition
POST   /api/airflow/dags/{dagId}/regenerate - Regenerate DAG file
GET    /api/airflow/dags/{dagId}/preview   - Preview generated DAG code
```

#### Request/Response Models

```csharp
public class GenerateDagRequest
{
    public string DagId { get; set; }
    public string EntityType { get; set; }
    public string Description { get; set; }
    public string Schedule { get; set; }  // e.g., "0 2 * * *"
    public int? TransformationProjectId { get; set; }
    public int? SparkJobId { get; set; }
    public List<int> TransformationRuleIds { get; set; }
    public DagConfiguration Configuration { get; set; }
}

public class DagConfiguration
{
    public int TimeoutSeconds { get; set; } = 1800;
    public int PollInterval { get; set; } = 30;
    public int Retries { get; set; } = 3;
    public int RetryDelayMinutes { get; set; } = 5;
    public string Owner { get; set; } = "airflow";
    public bool EmailOnFailure { get; set; } = true;
    public string Email { get; set; }
    public Dictionary<string, object> InputData { get; set; }
}
```

#### DAG Template

```python
# Generated DAG Template
"""
{description}

Auto-generated by TransformationService
Entity Type: {entity_type}
Generated: {timestamp}
"""

from datetime import datetime, timedelta
from airflow import DAG
from operators.spark_job_operator import SparkJobOperator
from operators.rule_engine_operator import RuleEngineOperator

default_args = {{
    'owner': '{owner}',
    'depends_on_past': False,
    'start_date': datetime({start_year}, {start_month}, {start_day}),
    'email': ['{email}'],
    'email_on_failure': {email_on_failure},
    'email_on_retry': False,
    'retries': {retries},
    'retry_delay': timedelta(minutes={retry_delay}),
}}

with DAG(
    '{dag_id}',
    default_args=default_args,
    description='{description}',
    schedule_interval='{schedule}',
    catchup=False,
    tags=['auto-generated', '{entity_type}', 'transformation'],
) as dag:
    
    transform_task = SparkJobOperator(
        task_id='transform_{entity_type}',
        spark_job_id={spark_job_id},
        entity_type='{entity_type}',
        input_data={input_data},
        timeout_seconds={timeout},
        poll_interval={poll_interval},
        http_conn_id='transformation_service',
    )
```

---

## Enhancement 2: Transformation Projects

### Objective

Group related transformation rules into projects/pipelines for better organization and management.

### Design

#### Database Schema

```sql
-- Table: TransformationProjects
CREATE TABLE "TransformationProjects" (
    "Id" SERIAL PRIMARY KEY,
    "Name" VARCHAR(255) NOT NULL,
    "Description" TEXT,
    "EntityType" VARCHAR(100) NOT NULL,
    "IsActive" BOOLEAN DEFAULT true,
    "ExecutionOrder" INT DEFAULT 0,
    "Configuration" JSONB,
    "CreatedBy" VARCHAR(100),
    "CreatedAt" TIMESTAMP DEFAULT NOW(),
    "UpdatedAt" TIMESTAMP DEFAULT NOW()
);

-- Table: TransformationProjectRules (Many-to-Many)
CREATE TABLE "TransformationProjectRules" (
    "Id" SERIAL PRIMARY KEY,
    "ProjectId" INT NOT NULL,
    "RuleId" INT NOT NULL,
    "ExecutionOrder" INT DEFAULT 0,
    "IsEnabled" BOOLEAN DEFAULT true,
    "CreatedAt" TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY ("ProjectId") REFERENCES "TransformationProjects"("Id") ON DELETE CASCADE,
    FOREIGN KEY ("RuleId") REFERENCES "TransformationRules"("Id") ON DELETE CASCADE,
    UNIQUE ("ProjectId", "RuleId")
);

-- Table: TransformationProjectExecutions (Audit Trail)
CREATE TABLE "TransformationProjectExecutions" (
    "Id" SERIAL PRIMARY KEY,
    "ProjectId" INT NOT NULL,
    "ExecutionId" UUID NOT NULL,
    "Status" VARCHAR(50) NOT NULL,
    "StartedAt" TIMESTAMP NOT NULL,
    "CompletedAt" TIMESTAMP,
    "RecordsProcessed" INT DEFAULT 0,
    "RecordsFailed" INT DEFAULT 0,
    "ErrorMessage" TEXT,
    "ExecutionMetadata" JSONB,
    FOREIGN KEY ("ProjectId") REFERENCES "TransformationProjects"("Id")
);

CREATE INDEX "IX_TransformationProjects_EntityType" ON "TransformationProjects"("EntityType");
CREATE INDEX "IX_TransformationProjectRules_ProjectId" ON "TransformationProjectRules"("ProjectId");
CREATE INDEX "IX_TransformationProjectRules_RuleId" ON "TransformationProjectRules"("RuleId");
CREATE INDEX "IX_TransformationProjectExecutions_ProjectId" ON "TransformationProjectExecutions"("ProjectId");
```

#### API Endpoints

```
POST   /api/transformation-projects              - Create project
GET    /api/transformation-projects              - List all projects
GET    /api/transformation-projects/{id}         - Get project details
PUT    /api/transformation-projects/{id}         - Update project
DELETE /api/transformation-projects/{id}         - Delete project
POST   /api/transformation-projects/{id}/rules   - Add rule to project
DELETE /api/transformation-projects/{id}/rules/{ruleId} - Remove rule
PUT    /api/transformation-projects/{id}/rules/order - Reorder rules
POST   /api/transformation-projects/{id}/execute - Execute project
GET    /api/transformation-projects/{id}/executions - Get execution history
```

#### Request/Response Models

```csharp
public class TransformationProject
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public string EntityType { get; set; }
    public bool IsActive { get; set; }
    public int ExecutionOrder { get; set; }
    public Dictionary<string, object> Configuration { get; set; }
    public List<ProjectRule> Rules { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class ProjectRule
{
    public int RuleId { get; set; }
    public string RuleName { get; set; }
    public string RuleType { get; set; }
    public int ExecutionOrder { get; set; }
    public bool IsEnabled { get; set; }
}

public class ExecuteProjectRequest
{
    public Dictionary<string, object> InputData { get; set; }
    public string ExecutionMode { get; set; } = "Spark";
    public int TimeoutSeconds { get; set; } = 1800;
}
```

---

## Enhancement 3: Rule Versioning

### Objective

Track transformation rule changes over time with full version history and rollback capability.

### Design

#### Database Schema

```sql
-- Table: TransformationRuleVersions
CREATE TABLE "TransformationRuleVersions" (
    "Id" SERIAL PRIMARY KEY,
    "RuleId" INT NOT NULL,
    "Version" INT NOT NULL,
    "Name" VARCHAR(255) NOT NULL,
    "Description" TEXT,
    "RuleType" VARCHAR(100) NOT NULL,
    "Configuration" JSONB NOT NULL,
    "IsActive" BOOLEAN,
    "ChangeType" VARCHAR(50) NOT NULL,  -- Created, Updated, Deleted
    "ChangedBy" VARCHAR(100),
    "ChangeReason" TEXT,
    "CreatedAt" TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY ("RuleId") REFERENCES "TransformationRules"("Id") ON DELETE CASCADE,
    UNIQUE ("RuleId", "Version")
);

-- Add version tracking to TransformationRules
ALTER TABLE "TransformationRules" 
ADD COLUMN "CurrentVersion" INT DEFAULT 1,
ADD COLUMN "LastModifiedBy" VARCHAR(100),
ADD COLUMN "LastModifiedAt" TIMESTAMP DEFAULT NOW();

CREATE INDEX "IX_TransformationRuleVersions_RuleId" ON "TransformationRuleVersions"("RuleId");
CREATE INDEX "IX_TransformationRuleVersions_CreatedAt" ON "TransformationRuleVersions"("CreatedAt");
```

#### API Endpoints

```
GET    /api/transformation-rules/{id}/versions           - Get version history
GET    /api/transformation-rules/{id}/versions/{version} - Get specific version
POST   /api/transformation-rules/{id}/rollback/{version} - Rollback to version
GET    /api/transformation-rules/{id}/diff/{v1}/{v2}     - Compare versions
```

#### Request/Response Models

```csharp
public class TransformationRuleVersion
{
    public int Id { get; set; }
    public int RuleId { get; set; }
    public int Version { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public string RuleType { get; set; }
    public Dictionary<string, object> Configuration { get; set; }
    public bool IsActive { get; set; }
    public string ChangeType { get; set; }
    public string ChangedBy { get; set; }
    public string ChangeReason { get; set; }
    public DateTime CreatedAt { get; set; }
}

public class RuleVersionDiff
{
    public int RuleId { get; set; }
    public int Version1 { get; set; }
    public int Version2 { get; set; }
    public List<FieldChange> Changes { get; set; }
}

public class FieldChange
{
    public string FieldName { get; set; }
    public object OldValue { get; set; }
    public object NewValue { get; set; }
    public string ChangeType { get; set; }  // Added, Modified, Removed
}
```

---

## Implementation Order

### Phase 1: Database Migrations (Week 1)

1. Create migration for Transformation Projects
2. Create migration for Rule Versioning
3. Create migration for Airflow DAG Definitions
4. Apply migrations and verify schema

### Phase 2: Core Services (Week 2)

1. Implement `TransformationProjectService`
2. Implement `RuleVersioningService`
3. Implement `AirflowDagGeneratorService`
4. Add unit tests for services

### Phase 3: API Controllers (Week 3)

1. Implement `TransformationProjectsController`
2. Implement `RuleVersionsController`
3. Implement `AirflowDagController`
4. Add integration tests

### Phase 4: UI Components (Week 4)

1. Create Project Management UI
2. Create Rule Version History UI
3. Create DAG Generator UI
4. Add validation and error handling

### Phase 5: Documentation & Testing (Week 5)

1. Update API documentation
2. Create user guides
3. End-to-end testing
4. Performance testing

---

## Success Criteria

### DAG Auto-Generation

- ✅ Can generate Airflow DAG from API call
- ✅ Generated DAG is syntactically correct
- ✅ DAG executes successfully in Airflow
- ✅ Can preview DAG before generation
- ✅ Can regenerate DAG after changes

### Transformation Projects

- ✅ Can create project with multiple rules
- ✅ Rules execute in specified order
- ✅ Can add/remove rules from project
- ✅ Execution history is tracked
- ✅ Can execute entire project via API

### Rule Versioning

- ✅ All rule changes are versioned
- ✅ Can view version history
- ✅ Can rollback to previous version
- ✅ Can compare versions (diff)
- ✅ Version metadata is captured

---

## Risk Mitigation

### Technical Risks

1. **DAG File Generation**
   - Risk: Generated DAG has syntax errors
   - Mitigation: Validate generated code, use templates, add tests

2. **Version Storage**
   - Risk: Large number of versions impacts performance
   - Mitigation: Add archival strategy, pagination, indexes

3. **Project Execution**
   - Risk: Long-running projects timeout
   - Mitigation: Configurable timeouts, progress tracking

### Operational Risks

1. **Airflow Integration**
   - Risk: Generated DAGs not recognized by Airflow
   - Mitigation: Follow Airflow best practices, test thoroughly

2. **Data Migration**
   - Risk: Existing rules need versioning
   - Mitigation: Create initial versions for all existing rules

---

## Next Steps

1. Review and approve enhancement plan
2. Create database migrations
3. Implement core services
4. Build API endpoints
5. Create UI components
6. Test and document

---

**Estimated Timeline**: 5 weeks  
**Priority**: High  
**Status**: Ready for Implementation

